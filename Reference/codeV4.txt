extends Control

# --- Node References ---
@onready var display_text = $VBoxContainer/DisplayText
@onready var choice_image = $VBoxContainer/ChoiceImage
@onready var choice_container = $VBoxContainer/ChoiceContainer
@onready var choice_buttons = [
	$VBoxContainer/ChoiceContainer/ChoiceButton1,
	$VBoxContainer/ChoiceContainer/ChoiceButton2,
	$VBoxContainer/ChoiceContainer/ChoiceButton3
]
# --- NEW EMBARKATION UI REFERENCES ---
@onready var embarkation_ui = $VBoxContainer/EmbarkationUI
@onready var confirm_button = $VBoxContainer/EmbarkationUI/ConfirmButton
@onready var summary_label = $VBoxContainer/EmbarkationUI/SummaryLabel

# References to the columns' dynamic content lists
@onready var middelkerke_unit_list = $VBoxContainer/EmbarkationUI/HBoxContainer/MiddelKerkeColumn/ScrollContainer/MiddelKerkeUnitList
@onready var westende_unit_list = $VBoxContainer/EmbarkationUI/HBoxContainer/WestendeColumn/ScrollContainer/WestendeColumnUnitList
@onready var nieuwpoort_unit_list = $VBoxContainer/EmbarkationUI/HBoxContainer/NieuwpoortColumn/ScrollContainer/NieuwpoortUnitList

# References to the columns' stat display labels
@onready var middelkerke_stats = $VBoxContainer/EmbarkationUI/HBoxContainer/MiddelKerkeColumn/MiddelKerkeStats
@onready var westende_stats = $VBoxContainer/EmbarkationUI/HBoxContainer/WestendeColumn/WestendeColumnStats
@onready var nieuwpoort_stats = $VBoxContainer/EmbarkationUI/HBoxContainer/NieuwpoortColumn/NieuwpoortStats

# --- Game Constants ---
const SOLDIERS_PER_MONITOR = 300; const TOTAL_MONITOR = 15
const TANKS_PER_LIGHTER = 6; const TANK_COMBAT_BONUS = 60
const TOTAL_REINFORCEMENT_BARGES = 90; const SOLDIERS_PER_BARGE = 200
const GROUND_ATTACK_BONUS = 150

# --- Game State Variables ---
enum Phases {
	START_GAME, INTELLIGENCE_BRIEFING, PLAN_OVERVIEW, NAVAL_SUPPORT_DECISION, NAVAL_SUPPORT_RESOLUTION, NAVAL_BOMBARDMENT_TARGETING_DECISION,ARMOUR_DECISION, BOMBARDMENT_PLAN_DECISION,
	Q_SHIP_DECISION, TIME_OF_DAY_DECISION, AIR_DOCTRINE_DECISION,
	PLANNING_SUMMARY, BOMBARDMENT_REPORT, EMBARKATION_ASSIGNMENT, LANDING_ASSIGNMENT, LANDING_REPORT, REINFORCEMENT_ASSIGNMENT,
	REINFORCEMENT_REPORT, SPY_REPORT,CONSOLIDATION_ASSIGNMENT, CONSOLIDATION_RESOLUTION, FINAL_OUTCOME, FINAL_ROLL_OF_HONOUR
}
var current_phase = Phases.START_GAME

# --- Data Structures & Planning Choices ---
var division_order_of_battle: Array = []
var naval_support_ships: Array = []
var targets = {
	"Middelkerke Bains": {"artillery": 25, "garrison": 4500, "battery_status": "Intact"},
	"Westende Bains": {"artillery": 20, "garrison": 3500, "battery_status": "Intact"},
	"Nieuwpoort Bains": {"artillery": 30, "garrison": 6500, "battery_status": "Intact"}
}
var monitors = []; var troop_landing_plan = {}; var tank_landing_plan = {}; var reinforcement_plan = {}
var consolidation_plan = {}
var landing_assignment_order = ["Middelkerke Bains", "Westende Bains", "Nieuwpoort Bains"]
var current_assignment_index = 0
var temp_redeployment_source = ""
var temp_assignment_value = 0 # For number input UI

var consolidation_turns_total := 3
var consolidation_turn_current := 1
var naval_support_choice = "steam"
var naval_bombardment_target_focus = "split"
var q_ship_assignment = "none"
var time_of_day = "day"
var tanks_chosen = false
var bombardment_plan = "gunners"
var air_doctrine = "none"
var threat_level = 0
var mustard_gas_used = false
var time_of_day_effective = "day"
var morning_mist_failed = false
var air_doctrine_event = ""
var rfc_used_this_turn := false

# --- Game Initialization ---
func _ready():
	randomize()
	confirm_button.pressed.connect(_on_choice_made.bind("Confirm Embarkation"))
	_create_and_apply_theme()
	start_new_game()

func start_new_game():
	var tex = load("res://assets/Map.jpeg")
	choice_image.texture = tex
	choice_image.visible = true
	populate_monitors()
	populate_division_structure() 
	troop_landing_plan.clear(); tank_landing_plan.clear(); reinforcement_plan.clear(); consolidation_plan.clear()
	threat_level = 0
	mustard_gas_used = false
	air_doctrine = "none"
	start_game_phase()

func populate_monitors():
	monitors.clear()
	var monitor_names = [
		"HMS Erebus", "HMS Terror", "HMS Marshal Soult", "HMS M21", "HMS Sir John Moore",
		"HMS Lord Clive", "HMS General Craufurd", "HMS Prince Eugene", "HMS Raglan",
		"HMS General Wolfe", "HMS Prince Rupert", "HMS Sir Thomas Picton",
		"HMS Abercrombie", "HMS Havelock", "HMS Roberts"
	]
	for i in range(TOTAL_MONITOR):
		monitors.append({"name": monitor_names[i], "carries": "troops", "soldiers": SOLDIERS_PER_MONITOR, "tanks_onboard": 0, "status": "Ready", "assigned_to": ""})
func populate_division_structure():
	division_order_of_battle.clear()
	
	# --- COLUMN "A" (2nd Brigade) -> Defaults to Middelkerke Bains ---
	division_order_of_battle.append({"name": "2nd Bde H.Q.", "strength": 100, "id": "2bde_hq", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "2nd Machine Gun Coy.", "strength": 184, "id": "2mg", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "216th Machine Gun Coy.", "strength": 184, "id": "216mg", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "2nd Trench Mortar Bty.", "strength": 65, "id": "2tm", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "1st Northants Regt.", "strength": 751, "id": "1north", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "2nd Sussex Regiment", "strength": 751, "id": "2sussex", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "1st Loyal N. Lancs.", "strength": 751, "id": "1loyal", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "2nd K.R.R. Corps", "strength": 751, "id": "2krr", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "409th Field Coy.", "strength": 197, "id": "409fc", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "1 Coy. 6th Welsh Regt.", "strength": 170, "id": "1coy6w_a", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "No.2 Field Ambulance", "strength": 139, "id": "2fa", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "113th Bty. R.F.A.", "strength": 109, "id": "113rfa", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "13th Cyclist Battn.", "strength": 294, "id": "13cyc", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "12th Motor M.G.Bty.", "strength": 46, "id": "12mmg", "current_dest": "Middelkerke Bains"})
	division_order_of_battle.append({"name": "Corps Intelligence (A)", "strength": 2, "id": "coint_a", "current_dest": "Middelkerke Bains"})
	
	# --- COLUMN "B" (3rd Brigade) -> Defaults to Westende Bains ---
	division_order_of_battle.append({"name": "3rd Bde H.Qrs.", "strength": 101, "id": "3bde_hq", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "3rd Machine Gun Coy.", "strength": 184, "id": "3mg", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "3rd Trench Mortar Bty.", "strength": 65, "id": "3tm", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "2nd Welsh Regiment", "strength": 751, "id": "2welsh", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "2nd R. Munster Fusrs.", "strength": 751, "id": "2munster", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "1st Bn.Gloster Regt.", "strength": 751, "id": "1gloster_b", "current_dest": "Westende Bains"})
	division_order_of_battle.append({"name": "1st S.Wales Borderers", "strength": 751, "id": "1swb", "current_dest": "Westende Bains"})
	# ... (and so on for all of 3rd Brigade's units)

	# --- COLUMN "C" (1st Brigade) -> Defaults to Nieuwpoort Bains ---
	division_order_of_battle.append({"name": "1st Bde H.Q.", "strength": 100, "id": "1bde_hq", "current_dest": "Nieuwpoort Bains"})
	division_order_of_battle.append({"name": "1st Machine Gun Coy.", "strength": 184, "id": "1mg", "current_dest": "Nieuwpoort Bains"})
	division_order_of_battle.append({"name": "1st Trench Mortar Bty.", "strength": 65, "id": "1tm", "current_dest": "Nieuwpoort Bains"})
	division_order_of_battle.append({"name": "1st Bn. The Black Watch", "strength": 751, "id": "1bw", "current_dest": "Nieuwpoort Bains"})
	division_order_of_battle.append({"name": "1st Cameron Hdrs.", "strength": 751, "id": "1cameron", "current_dest": "Nieuwpoort Bains"})
	# ... (and so on for all of 1st Brigade's units)
# --- UI Helper Function ---
func setup_choices(options: Array):
	choice_container.visible = true
	for i in range(choice_buttons.size()):
		var button = choice_buttons[i]
		
		# First, disconnect any old connections from a previous turn to prevent the signal from firing multiple times.
		# This is a good practice when re-using buttons like this.
		if button.is_connected("pressed", _on_choice_made):
			button.disconnect("pressed", _on_choice_made)

		# Now, configure the button based on the current options
		if i < options.size():
			button.text = options[i]
			button.visible = true
			# Connect the signal and use .bind() to pass the button's current text as an argument.
			# This is the key to fixing your issue.
			button.pressed.connect(_on_choice_made.bind(button.text))
		else:
			button.visible = false
			
	if options.is_empty():
		choice_container.visible = false

# --- Input Handling ---
func _on_choice_made(choice: String):
	# --- THIS IS THE TEST LINE ---
	print("Button pressed! Choice was '", choice, "' in phase: ", Phases.keys()[current_phase])

	# Route input to the correct handler based on phase type
	if current_phase == Phases.LANDING_ASSIGNMENT or current_phase == Phases.REINFORCEMENT_ASSIGNMENT:
		handle_assignment_input(choice)
		return

	# Standard choice handling for all other phases
	match current_phase:
		Phases.START_GAME:
			start_intelligence_briefing_phase()
		Phases.INTELLIGENCE_BRIEFING:
			start_plan_overview_phase()
		Phases.PLAN_OVERVIEW:
			start_naval_support_phase()
		Phases.NAVAL_SUPPORT_DECISION: 
			process_naval_support_choice(choice)
		Phases.NAVAL_SUPPORT_RESOLUTION: 
			start_naval_bombardment_targeting_phase()
		Phases.NAVAL_BOMBARDMENT_TARGETING_DECISION:
			process_naval_bombardment_targeting_choice(choice)
		Phases.ARMOUR_DECISION: 
			process_armour_choice(choice)
		Phases.BOMBARDMENT_PLAN_DECISION: 
			process_bombardment_plan_choice(choice)
		Phases.Q_SHIP_DECISION: 
			process_q_ship_choice(choice)
		Phases.TIME_OF_DAY_DECISION: 
			process_time_of_day_choice(choice)
		Phases.AIR_DOCTRINE_DECISION: 
			process_air_doctrine_choice(choice)
		Phases.PLANNING_SUMMARY:
			start_bombardment_report_phase()
		Phases.BOMBARDMENT_REPORT:
			start_landing_assignment_phase()
		Phases.LANDING_REPORT:
			start_embarkation_assignment_phase()
		Phases.EMBARKATION_ASSIGNMENT: 
			resolve_main_force_landing()
		Phases.REINFORCEMENT_REPORT: 
			start_spy_report_phase()
		Phases.SPY_REPORT: 
			start_consolidation_phase()
		Phases.CONSOLIDATION_ASSIGNMENT:
			if temp_redeployment_source != "": 
				process_redeployment_destination(choice)
			else: 
				process_consolidation_choice(choice)
		Phases.CONSOLIDATION_RESOLUTION:
			if consolidation_turn_current < consolidation_turns_total: 
				_advance_to_next_consolidation_turn()
			else: 
				determine_final_outcome()
		Phases.FINAL_OUTCOME: 
			start_roll_of_honour_phase()
		Phases.FINAL_ROLL_OF_HONOUR: 
			setup_choices([]) # Hide buttons at end of game
func start_game_phase():
	current_phase = Phases.START_GAME
	var message = "--- OPERATION HUSH — BRIEFING ---\n\n"
	message += "For three years, the stalemate on the Western Front has bled the Empire white. Command has sanctioned a bold stroke: an amphibious landing to outflank the German line where it meets the sea.\n\n"
	message += "The German-held Belgian coast is a dagger pointed at our supply lines. The ports of Zeebrugge and Ostend serve as bases for the U-boats and destroyers that plague our shipping...\n\n"
	message += "Your objectives are twofold:\n • Objective 1: Seize the designated beachheads.\n • Objective 2: Neutralise the enemy batteries to enable a general advance from the Ypres Salient.\n\n"
	message += "The success of the entire Third Battle of Ypres may rest on your decisions."
	
	display_text.text = message
	setup_choices(["View Intelligence Briefing"])
func start_intelligence_briefing_phase():
	current_phase = Phases.INTELLIGENCE_BRIEFING
	var tex = load("res://assets/MataHari.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	var message = "--- INTELLIGENCE BRIEFING ---\n\n"
	message += "The three landing sites have been chosen for their strategic value:\n"
	message += " • Middelkerke Bains: 1.75 miles behind the German Third line.\n"
	message += " • Westende Bains: 1 mile behind the German Second line.\n"
	message += " • Nieuwpoort Bains: 0.75 miles behind the German Second Line.\n\n"
	message += "ENEMY DISPOSITIONS:\n"
	message += "The sector is held by the 3rd German Marine Korps Flandern. The 199th Division is held as a mobile reserve.\n\n"
	# Calculate and display the strength for each target based on the new formula
	var m_art = targets["Middelkerke Bains"]["artillery"]
	var m_gar = targets["Middelkerke Bains"]["garrison"]
	var m_strength = (m_art * 200) + m_gar
	message += " > Middelkerke ('Raversyde'): " + str(m_art) + " guns, " + str(m_gar) + " men. (Total Strength: " + str(m_strength) + ")\n"

	var w_art = targets["Westende Bains"]["artillery"]
	var w_gar = targets["Westende Bains"]["garrison"]
	var w_strength = (w_art * 200) + w_gar
	message += " > Westende: " + str(w_art) + " guns, " + str(w_gar) + " men. (Total Strength: " + str(w_strength) + ")\n"
	
	var n_art = targets["Nieuwpoort Bains"]["artillery"]
	var n_gar = targets["Nieuwpoort Bains"]["garrison"]
	var n_strength = (n_art * 200) + n_gar
	message += " > Nieuwpoort: " + str(n_art) + " guns, " + str(n_gar) + " men. (Total Strength: " + str(n_strength) + ")\n\n"

	message += "TERRAIN ANALYSIS:\n"
	message += "A 30-foot seawall lines the coast. The immediate vicinity consists of sand dunes where the garrisons and artillery are well dug-in, favouring the defenders. Some areas have also been deliberately flooded."

	display_text.text = message
	setup_choices(["View Operation Plan"])
	
# CHANGE 2: New function for the plan overview phase.
func start_plan_overview_phase():
	current_phase = Phases.PLAN_OVERVIEW
	var tex = load("res://assets/prepare.jpeg")
	choice_image.texture = tex
	choice_image.visible = true
	var message = "--- OPERATION PLAN & OBJECTIVES ---\n\n"
	message += "14,000 men of the 1st Division have been preparing for this assault in great secrecy at a replica facility in Dunkirk, codenamed 'Hush Island', practicing both day and night assaults.\n\n"
	message += "The operation will consist of the following stages:\n"
	message += "1. Naval ship-to-shore bombardment to weaken defensive positions.\n"
	message += "2. The Royal Naval Division, transported by monitors, will land and secure beachheads. Specially built pontoons will be moved to the sea wall, allowing the main 1st Division force to disembark under cover of a smoke screen.\n"
	message += "3. The invasion force must consolidate its positions, eliminating enemy artillery and garrisons.\n"
	message += "4. Breakout from the beaches to secure inland bridges and await link-up with General Rawlinson's 5th Corps.\n\n"
	message += "--- VICTORY CONDITION ---\n"
	message += "The complete elimination of all three enemy batteries and the routing of all three garrisons."

	display_text.text = message
	setup_choices(["Begin Planning"])
func start_naval_support_phase():
	current_phase = Phases.NAVAL_SUPPORT_DECISION
	var tex = load("res://assets/warspite.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	
	var message = "--- STEP 1: NAVAL SUPPORT ---\n\n"
	message += "The Dover Patrol will provide the initial coastal barrage using a number of their obsolete Tribal-class destroyers.\n\n"
	message += "These are old, steam-powered ships armed with 12-pounder guns. Their advantage is that they are already in position, and the Germans are accustomed to their presence off the coast.\n\n"
	message += "You could, however, petition the Admiralty for the use of the latest Queen Elizabeth-class Dreadnoughts. Their 15-inch guns offer vastly superior accuracy. Be warned: they are currently in Scapa Flow. Moving these capital ships will delay the operation, alert the enemy, and there is no guarantee the Admiralty will approve the request."
	
	display_text.text = message
	
	setup_choices(["Rely on the Dover Patrol", "Petition for Dreadnoughts"])
func process_naval_support_choice(choice):
	if choice == "Rely on the Dover Patrol":
		naval_support_choice = "destroyers"
		naval_support_ships = [
			{"name": "HMS Afridi", "class": "tribal", "status": "Ready"},
			{"name": "HMS Cossack", "class": "tribal", "status": "Ready"},
			{"name": "HMS Mohawk", "class": "tribal", "status": "Ready"},
			{"name": "HMS Tartar", "class": "tribal", "status": "Ready"}
		]
	elif choice == "Petition for Dreadnoughts":
		# Chance of approval is now 50/50
		if randf() < 0.5:
			# On success, you get the better ships but at a cost.
			naval_support_choice = "dreadnought_success"
			threat_level += 2
			naval_support_ships = [
				{"name": "HMS Warspite", "class": "qe", "status": "Ready"},
				{"name": "HMS Barham", "class": "qe", "status": "Ready"}
			]
		else:
			# On failure, the petition is denied, and you fall back to the destroyers.
			naval_support_choice = "dreadnought_failure"
			naval_support_ships = [
				{"name": "HMS Afridi", "class": "tribal", "status": "Ready"},
				{"name": "HMS Cossack", "class": "tribal", "status": "Ready"},
				{"name": "HMS Mohawk", "class": "tribal", "status": "Ready"},
				{"name": "HMS Tartar", "class": "tribal", "status": "Ready"}
			]
			
	start_naval_support_resolution_phase()
func start_naval_support_resolution_phase():
	current_phase = Phases.NAVAL_SUPPORT_RESOLUTION
	var tex = load("res://assets/Jelly.png")
	choice_image.texture = tex
	choice_image.visible = true
	var message = ""
	
	if naval_support_choice == "dreadnought_success":
		message += "A dispatch arrives, heavy with the gravity of its decision. It reads:\n'REQUEST GRANTED. BE ADVISED, THE ABSENCE OF WARSPITE AND BARHAM FROM THE GRAND FLEET PRESENTS A GRAVE STRATEGIC VULNERABILITY. THIS OPERATION MUST YIELD RESULTS COMMENSURATE WITH THE RISK I HAVE UNDERTAKEN. DO NOT FAIL. - JELLICOE'\n"
	elif naval_support_choice == "dreadnought_failure":
		message += "A curt dispatch arrives from the Admiralty. It reads:\n'REFERENCE YOUR REQUEST FOR CAPITAL SHIPS. UNACCEPTABLE RISK. THE GRAND FLEET'S STRENGTH MUST BE PRESERVED AT ALL COSTS TO COUNTER THE HIGH SEAS FLEET. YOU WILL MAKE DO WITH THE ASSETS ALLOCATED. - JELLICOE'\n"
	else: # This covers the "destroyers" choice
		message += "Admiralty signals confirmation. The assets of the Dover Patrol are deemed sufficient for the task. Proceed as planned.\n"
		
	message += "\nThe following ships are assigned to the bombardment force:\n"
	for ship in naval_support_ships:
		message += " > " + ship["name"] + "\n"
		
	display_text.text = message
	setup_choices(["Set Targeting Priority"])
func start_naval_bombardment_targeting_phase():
	current_phase = Phases.NAVAL_BOMBARDMENT_TARGETING_DECISION
	var tex = load("res://assets/target.jpeg")
	choice_image.texture = tex
	choice_image.visible = true
	var message = "--- STEP 2: BOMBARDMENT TARGETING ---\n\n"
	message += "The bombardment is the critical first step. The fleet's gunnery officers await your targeting doctrine.\n\n"
	message += "Your choice will determine the focus of the barrage:\n"
	message += " • Target the Batteries: Prioritise silencing the heavy guns that threaten our landing flotillas.\n"
	message += " • Target the Garrisons: Prioritise decimating the infantry in their trenches to aid our assaulting troops.\n\n"
	message += "What is the fleet's priority?"
	
	display_text.text = message
	setup_choices(["Focus on Batteries", "Focus on Garrisons", "Split Fire"])
func process_naval_bombardment_targeting_choice(choice):
	if choice == "Focus on Batteries":
		naval_bombardment_target_focus = "batteries"
	elif choice == "Focus on Garrisons":
		naval_bombardment_target_focus = "garrison"
	elif choice == "Split Fire":
		naval_bombardment_target_focus = "split"
	
	start_bombardment_plan_phase()	
func start_armour_phase():
	current_phase = Phases.ARMOUR_DECISION
	var tex = load("res://assets/HAig.png")
	choice_image.texture = tex
	choice_image.visible = true
	
	# This line now dynamically counts the remaining troop monitors for accurate text.
	var troop_monitors_count = monitors.filter(func(m): return m["carries"] == "troops").size()
	
	var message = "--- STEP 5: ARMOURED SUPPORT ---\n\n"
	message += "Field Marshal Haig has burst in, demanding that tanks be included in the assault.\n\n"
	message += "This would involve converting three of your " + str(troop_monitors_count) + " available troop-carrying monitors into specialist tank lighters, removing their initial infantry capacity entirely."
	
	display_text.text = message
	setup_choices(["Reject Haig's Plan", "Approve Haig's Plan"])
func process_armour_choice(choice):
	if choice == "1":
		tanks_chosen = false
	elif choice == "2":
		tanks_chosen = true
		refit_monitors_for_tanks()
	start_time_of_day_phase()

func start_bombardment_plan_phase():
	current_phase = Phases.BOMBARDMENT_PLAN_DECISION
	var tex = load("res://assets/baloon.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	var message = "--- STEP 3: BOMBARDMENT METHOD ---\n\n"
	message += "The Dover Patrol has fifteen monitors assigned to support the mission. Six are reserved for landing the enormous pontoons, leaving nine available for close support.\n\n"
	message += "The RNAS, however, would like to requisition one of these nine to carry an observation balloon. This would provide the fleet with live feedback on hits and misses, potentially increasing the barrage's accuracy.\n\n"
	message += "Separately, Admiral Bacon has a radical idea: use two monitors as static 'islands'. This would give the gunners a fixed point of reference, allowing them to triangulate their fire—a high-risk gamble with the potential for devastating accuracy.\n\n"
	message += "Or, you can simply trust the gunners, freeing up all nine monitors for their primary support role."
	
	display_text.text = message
	setup_choices(["RNAS Balloon (Cost: 1 Monitor)", "Bacon's 'Islands' (Cost: 2 Monitors)", "Trust the Gunners (Cost: 0)"])
func process_bombardment_plan_choice(choice):
	var cost = 0
	if choice == "RNAS Balloon (Cost: 1 Monitor)": 
		bombardment_plan = "balloons"
		cost = 1
	elif choice == "Bacon's 'Islands' (Cost: 2 Monitors)": 
		bombardment_plan = "bacon"
		cost = 2
	elif choice == "Trust the Gunners (Cost: 0)": 
		bombardment_plan = "gunners"
	
	apply_monitor_costs(cost)
	

	start_q_ship_phase()

func start_q_ship_phase():
	current_phase = Phases.Q_SHIP_DECISION
	var tex = load("res://assets/qSHip.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	display_text.text = "--- STEP 4: SUBMARINE DEFENCE ---\n\nU‑boats are active in the sector. Q‑Ships can be deployed to screen either the fire‑support fleet or the landing flotillas. Their presence will likely put the enemy on alert.\n\nYour choice:"
	setup_choices(["Screen Fire Support", "Screen Landing Force", "No Q-Ships"])

func process_q_ship_choice(choice):
	if choice == "Screen Fire Support": 
		q_ship_assignment = "fleet"
		threat_level += 1 # Deploying Q-ships increases enemy alertness
	elif choice == "Screen Landing Force": 
		q_ship_assignment = "screen"
		threat_level += 1 # Deploying Q-ships increases enemy alertness
	elif choice == "No Q-Ships": 
		q_ship_assignment = "none"
		# No change to threat level if no ships are deployed
	
	# Flow now proceeds to the Armour decision phase.
	start_armour_phase()

func start_time_of_day_phase():
	current_phase = Phases.TIME_OF_DAY_DECISION
	# Text updated from Step 5 to Step 6
	display_text.text = "--- STEP 6: H-HOUR ---\n\nChoose the timing of the assault carefully:\n\n • Night: Cloaks approach, but treacherous ranging.\n • Morning: Mist veils flotillas, but can fail.\n • Daylight: Perfect visibility for both sides."
	setup_choices(["Night Assault", "Morning Landings", "Daylight Assault"])
func process_time_of_day_choice(choice):
	if choice == "1": time_of_day = "night"
	elif choice == "2": time_of_day = "morning"
	elif choice == "3": time_of_day = "day"
	start_air_doctrine_phase()

func start_air_doctrine_phase():
	current_phase = Phases.AIR_DOCTRINE_DECISION
	var tex = load("res://assets/Flashheart.jpeg")
	choice_image.texture = tex
	choice_image.visible = true
	display_text.text = "--- STEP 7: AIR DOCTRINE ---\n\nThe Royal Flying Corps is eager to help. Where do you want them?\n\n • Air Reconnaissance: Estimate enemy strength.\n • Ground Attack: Strafe trenches and gun-pits."
	setup_choices(["Air Reconnaissance", "Ground Attack"])

func process_air_doctrine_choice(choice):
	if choice == "1": air_doctrine = "recon"
	elif choice == "2": air_doctrine = "ground_attack"
	show_planning_summary()

func show_planning_summary():
	current_phase = Phases.PLANNING_SUMMARY
	var troop_monitors_count = monitors.filter(func(m): return m["carries"] == "troops").size()
	var tank_lighters_count  = monitors.filter(func(m): return m["carries"] == "tanks").size()
	var message = "--- OPERATION PLAN FINALIZED ---\n\n"
	message += "Naval Support: " + naval_support_choice.capitalize() + "s\n"
	message += "Bombardment Focus: " + naval_bombardment_target_focus.capitalize() + "\n"
	message += "Bombardment Plan: " + bombardment_plan.capitalize() + "\n"
	message += "Air Doctrine: " + air_doctrine.replace("_", " ").capitalize() + "\n"
	message += "H-Hour: " + time_of_day.capitalize() + "\n"
	var u_line = "U-Boat Defence: "
	u_line += "None" if q_ship_assignment == "none" else "Screen " + q_ship_assignment.capitalize()
	message += u_line + "\n\n"
	message += "Your available landing force is:\n"
	message += " > " + str(troop_monitors_count) + " Troop Monitors (" + str(SOLDIERS_PER_MONITOR) + " each = " + str(troop_monitors_count * SOLDIERS_PER_MONITOR) + " men)\n"
	message += " > " + str(tank_lighters_count) + " Tank Lighters\n\n"
	message += "Reserve (at sea):\n"
	message += " > " + str(TOTAL_REINFORCEMENT_BARGES) + " Trawlers (" + str(SOLDIERS_PER_BARGE) + " each = " + str(TOTAL_REINFORCEMENT_BARGES * SOLDIERS_PER_BARGE) + " men)\n\n"
	message += "Current Threat Level: " + str(threat_level) + "\n\n"
	message += "Press Confirm to execute bombardment."
	display_text.text = message
	setup_choices(["Begin Bombardment"])

# --- ASSIGNMENT & RESOLUTION PHASES ---
func start_bombardment_report_phase():
	current_phase = Phases.BOMBARDMENT_REPORT
	var tex = load("res://assets/MataHari.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	
	var report = "--- BOMBARDMENT REPORT ---\n\n"
	report += "The pre-dawn gloom is shattered as the fleet opens fire. Mile-long flashes of cordite illuminate the ships, followed seconds later by the earth-shaking arrival of the shells on the coast. The Belgian shore disappears behind a wall of smoke, seawater, and pulverised earth.\n"
	
	# Add dramatic submarine contact text
	report += _fleet_sub_contact_lines(_get_active_fire_support())
	
	# Add observation report that changes based on the chosen method
	var observation_report = ""
	if bombardment_plan == "gunners":
		observation_report = "\nLookouts squint, trying to pierce the gloom. Without clear observation, the gunnery officer offers a conservative damage estimate, trusting the methodical bracketing of his gun crews.\n"
	elif bombardment_plan == "balloons":
		observation_report = "\nA signal lamp winks from the RNAS observation balloon, high above the chaos. 'OBSERVING... MULTIPLE... DIRECT HITS ON EMPLACEMENTS... REPEATING... DIRECT HITS...'\n"
	elif bombardment_plan == "bacon":
		observation_report = "\nThe radio crackles with a frantic report from the forward observers on Bacon's static monitors. Their unprecedented proximity allows for terrifyingly precise corrections. 'They're walking the shells right into the trenches! God save the poor souls in there...'\n"
	report += observation_report

	report += "\nFinal Damage Assessment:\n"
	
	# Loop through each target to calculate and report damage
	for target_name in targets.keys():
		var t = targets[target_name]
		
		# Store pre-bombardment stats
		var pre_art = t["artillery"]
		var pre_gar = t["garrison"]
		var initial_strength = (pre_art * 200) + pre_gar
		
		# Run the bombardment calculation
		bombard_target(target_name)
		
		# Calculate post-bombardment strength
		var post_art = targets[target_name]["artillery"]
		var post_gar = targets[target_name]["garrison"]
		var final_strength = (post_art * 200) + post_gar
		
		var strength_reduction = initial_strength - final_strength
		
		# Format the new report string
		report += "\n > " + target_name + ":\n"
		report += "   Initial: " + str(pre_art) + " guns, " + str(pre_gar) + " garrison.\n"
		report += "   Remaining: " + str(post_art) + " guns, " + str(post_gar) + " garrison.\n"
		report += "   Combat Strength Reduction: " + str(strength_reduction)

	display_text.text = report
	setup_choices(["Proceed to Landing Assignments"])

func start_landing_assignment_phase():
	current_phase = Phases.LANDING_ASSIGNMENT
	troop_landing_plan.clear()
	tank_landing_plan.clear()
	current_assignment_index = 0
	var type_to_assign = "tanks" if tanks_chosen else "troops"
	ask_for_next_assignment(type_to_assign)

func ask_for_next_assignment(type):
	temp_assignment_value = 0
	var total_vessels = monitors.filter(func(m): return m["carries"] == type).size()
	var plan = tank_landing_plan if type == "tanks" else troop_landing_plan
	var vessel_name = "Tank Lighters" if type == "tanks" else "Troop Monitors"
	var assigned = 0
	for beach in plan: assigned += plan[beach]
	var remaining = total_vessels - assigned
	var current_beach = landing_assignment_order[current_assignment_index]
	var message = "--- " + vessel_name.to_upper() + " ASSIGNMENT ---\n\n"
	message += "You have " + str(remaining) + " " + vessel_name + " remaining.\n"
	message += "Assign to " + current_beach + ":\n\n"
	message += "         " + str(temp_assignment_value) + "         \n"
	display_text.text = message
	setup_choices(["➖", "➕", "Assign"])

func process_landing_assignment(player_input):
	var type = "troops"
	if tanks_chosen and not tank_landing_plan.has(landing_assignment_order.back()): type = "tanks"
	var plan = tank_landing_plan if type == "tanks" else troop_landing_plan
	var num_assigned = int(player_input)
	var current_beach = landing_assignment_order[current_assignment_index]
	plan[current_beach] = num_assigned
	current_assignment_index += 1
	var assigned_so_far = 0
	for beach in plan: assigned_so_far += plan[beach]
	var total_vessels = monitors.filter(func(m): return m["carries"] == type).size()
	if assigned_so_far >= total_vessels or current_assignment_index >= landing_assignment_order.size():
		var remaining = total_vessels - assigned_so_far
		if current_assignment_index < landing_assignment_order.size():
			plan[landing_assignment_order[current_assignment_index]] = remaining
		while current_assignment_index < landing_assignment_order.size():
			if not plan.has(landing_assignment_order[current_assignment_index]):
				plan[landing_assignment_order[current_assignment_index]] = 0
			current_assignment_index += 1
		if type == "tanks":
			current_assignment_index = 0
			ask_for_next_assignment("troops")
		else:
			resolve_landings()
	else:
		ask_for_next_assignment(type)

func resolve_landings(): # This now resolves the INITIAL monitor/tank landing
	current_phase = Phases.LANDING_REPORT
	var tex = load("res://assets/landing.jpeg") # Use a suitable image
	choice_image.texture = tex
	choice_image.visible = true
	embarkation_ui.visible = false # Make sure the embarkation UI is hidden

	var report = "--- INITIAL LANDING REPORT ---\n\n"
	report += "Under the cover of smoke, the monitors approach the sea wall. The huge pontoon bridges are maneuvered into place as Royal Marines provide covering fire. The success of this vital first wave varies across the front.\n\n"

	# Loop through each beach to resolve the first wave
	for beach in landing_assignment_order:
		var target_data = targets[beach]
		var enemy_strength = (target_data.artillery * 100) + target_data.garrison # Simplified strength for this phase
		
		var monitors_assigned = troop_landing_plan.get(beach, 0)
		var tanks_assigned = tank_landing_plan.get(beach, 0)
		
		var attacker_strength = (monitors_assigned * SOLDIERS_PER_MONITOR) + (tanks_assigned * TANK_COMBAT_BONUS)
		
		report += " > " + beach + ":\n"
		
		# Determine outcome and set a status
		if attacker_strength > enemy_strength * 0.75:
			target_data["beach_status"] = "Secured"
			report += "   A strong foothold has been established! The enemy is falling back from the sea wall.\n"
		elif attacker_strength > enemy_strength * 0.3:
			target_data["beach_status"] = "Contested"
			report += "   Fierce fighting is taking place on the promenade. Our troops are pinned down but holding.\n"
		else:
			target_data["beach_status"] = "Repulsed"
			report += "   The assault was beaten back by withering fire. The survivors have withdrawn to the monitors.\n"
			
		# Store the initial landed force for later phases
		target_data["landed_force"] = monitors_assigned * SOLDIERS_PER_MONITOR
		target_data["operational_tanks"] = tanks_assigned # Simplified for now

	display_text.text = report
	setup_choices(["Prepare Main Force Embarkation"])
func resolve_main_force_landing():
	current_phase = Phases.REINFORCEMENT_REPORT # We can reuse this phase name or make a new one
	
	embarkation_ui.visible = false
	choice_image.visible = true
	
	# Calculate the main force strength for each beach from the division data
	var main_force_strength = {
		"Middelkerke Bains": 0,
		"Westende Bains": 0,
		"Nieuwpoort Bains": 0
	}
	
	for unit in division_order_of_battle:
		main_force_strength[unit.current_dest] += unit.strength
		
	var report = "--- MAIN FORCE LANDING REPORT ---\n\n"
	report += "Following the initial assault, the main body of the 1st Division comes ashore via the pontoons, reinforcing the beachheads.\n\n"
	
	# Add the main force to the existing landed force
	for beach in landing_assignment_order:
		targets[beach].landed_force += main_force_strength[beach]
		report += " > " + beach + " has been reinforced with " + str(main_force_strength[beach]) + " men.\n"
		
	display_text.text = report
	setup_choices(["View Intelligence Report"]) # Flow into the next part of the game
func start_reinforcement_assignment_phase():
	current_phase = Phases.REINFORCEMENT_ASSIGNMENT
	current_assignment_index = 0
	reinforcement_plan = {}
	ask_for_next_reinforcement_assignment()

func ask_for_next_reinforcement_assignment():
	temp_assignment_value = 0
	var assigned = 0
	for beach in reinforcement_plan: assigned += reinforcement_plan[beach]
	var remaining = TOTAL_REINFORCEMENT_BARGES - assigned
	var current_beach = landing_assignment_order[current_assignment_index]
	var message = "--- REINFORCEMENT PHASE ---\n\n"
	for beach_name in landing_assignment_order:
		message += " > " + beach_name + ": " + targets[beach_name].get("beach_status", "Unknown") + "\n"
	message += "\nYou have " + str(remaining) + " trawlers remaining.\n"
	message += "Assign to " + current_beach + ":\n\n"
	message += "         " + str(temp_assignment_value) + "         \n"
	display_text.text = message
	setup_choices(["➖", "➕", "Assign"])

func process_reinforcement_assignment(player_input):
	var num = int(player_input)
	var current_beach = landing_assignment_order[current_assignment_index]
	reinforcement_plan[current_beach] = num
	current_assignment_index += 1
	var assigned_so_far = 0
	for beach in reinforcement_plan: assigned_so_far += reinforcement_plan[beach]
	var remaining = TOTAL_REINFORCEMENT_BARGES - assigned_so_far
	if current_assignment_index >= landing_assignment_order.size() - 1:
		reinforcement_plan[landing_assignment_order.back()] = remaining
		resolve_reinforcements()
	else:
		ask_for_next_reinforcement_assignment()

func resolve_reinforcements():
	current_phase = Phases.REINFORCEMENT_REPORT
	# (Your full reinforcement logic is assumed here)
	display_text.text = "--- REINFORCEMENT ACTION REPORT ---\n\n(Reinforcements are landing...)"
	setup_choices(["View Intelligence Report"])

func start_spy_report_phase():
	current_phase = Phases.SPY_REPORT
	var tex = load("res://assets/break.jpg")
	choice_image.texture = tex
	choice_image.visible = true
	# (Your spy report logic here)
	display_text.text = "--- FIELD INTELLIGENCE REPORT ---\n\n(Agent reports enemy movements...)"
	setup_choices(["Begin Consolidation Phase"])
func start_embarkation_assignment_phase():
	print("--- Starting Embarkation Phase ---") # DEBUG
	print("Total units in Order of Battle: ", division_order_of_battle.size()) # DEBUG
	current_phase = Phases.EMBARKATION_ASSIGNMENT
	# Hide old UI, show new UI
	choice_container.visible = false
	choice_image.visible = false
	embarkation_ui.visible = true
	display_text.text = "--- EMBARKATION & ASSIGNMENT ---\nThe bombardment is complete. Re-assign units between beachheads as required. The logistical impact (barges required) will update with each change."
	
	draw_embarkation_ui()
func start_consolidation_phase():
	current_phase = Phases.CONSOLIDATION_ASSIGNMENT
	consolidation_turn_current = 1
	current_assignment_index = 0
	consolidation_plan.clear()
	rfc_used_this_turn = false
	ask_for_next_consolidation_order()

func ask_for_next_consolidation_order():
	var current_beach = landing_assignment_order[current_assignment_index]
	var beach_data = targets[current_beach]
	var status = beach_data.get("beach_status", "No Landing")
	var message = "--- CONSOLIDATION — TURN " + str(consolidation_turn_current) + " ---\n\n"
	message += "Orders for " + current_beach + " (Status: " + status + ")\n"
	message += "Landed Force: ~" + str(beach_data.get("landed_force", 0)) + " men, " + str(beach_data.get("operational_tanks", 0)) + " tanks.\n"
	display_text.text = message
	if status == "Secured" or status == "Dominant":
		setup_choices(["Assault Battery", "Naval Support", "Push Inland"])
	elif status == "Pinned Down":
		setup_choices(["Assault (Desperate)", "Naval Support", "Dig In"])
	else:
		setup_choices(["Do Nothing"])

func process_consolidation_choice(choice):
	var current_beach = landing_assignment_order[current_assignment_index]
	var status = targets[current_beach].get("beach_status", "No Landing")
	var action = ""
	if status == "Secured" or status == "Dominant":
		if choice == "1": action = "assault_battery"
		elif choice == "2": action = "naval_support"
		elif choice == "3": action = "push_inland"
	elif status == "Pinned Down":
		if choice == "1": action = "assault_battery"
		elif choice == "2": action = "naval_support"
		elif choice == "3": action = "dig_in"
	else:
		action = "dig_in"
	consolidation_plan[current_beach] = {"action": action}
	current_assignment_index += 1
	if current_assignment_index < landing_assignment_order.size():
		ask_for_next_consolidation_order()
	else:
		resolve_consolidation_turn()

func resolve_consolidation_turn():
	current_phase = Phases.CONSOLIDATION_RESOLUTION
	# (Your consolidation logic here)
	var report = "--- CONSOLIDATION TURN " + str(consolidation_turn_current) + " REPORT ---\n\n(Player and enemy actions are resolved...)"
	display_text.text = report
	if consolidation_turn_current < consolidation_turns_total:
		setup_choices(["Plan Next Turn (" + str(consolidation_turn_current + 1) + ")"])
	else:
		setup_choices(["See Final Outcome"])

func determine_final_outcome():
	current_phase = Phases.FINAL_OUTCOME
	# (Your final outcome logic here)
	display_text.text = "--- FINAL OPERATION OUTCOME ---\n\n(Victory or Stalemate...)"
	setup_choices(["View Roll of Honour"])

func start_roll_of_honour_phase():
	current_phase = Phases.FINAL_ROLL_OF_HONOUR
	# (Your roll of honour logic here)
	display_text.text = "--- OPERATION HUSH: ROLL OF HONOUR ---\n\n(Casualties are tallied...)"
	setup_choices(["Operation Complete"])

# --- HELPER & BACKGROUND LOGIC ---
func handle_assignment_input(choice: String):
	# Determine which assignment phase we are in
	var is_landing = (current_phase == Phases.LANDING_ASSIGNMENT)
	
	var type = ""
	var total_units = 0
	var plan = {}
	
	if is_landing:
		type = "troops"
		if tanks_chosen and not tank_landing_plan.has(landing_assignment_order.back()):
			type = "tanks"
		total_units = monitors.filter(func(m): return m["carries"] == type).size()
		plan = tank_landing_plan if type == "tanks" else troop_landing_plan
	else: # Reinforcement
		total_units = TOTAL_REINFORCEMENT_BARGES
		plan = reinforcement_plan
		
	var assigned_so_far = 0
	for beach in plan: assigned_so_far += plan[beach]
	var remaining = total_units - assigned_so_far
	
	# --- THIS IS THE CORRECTED LOGIC ---
	if choice == "➖":
		temp_assignment_value = max(0, temp_assignment_value - 1)
	elif choice == "➕":
		temp_assignment_value = min(remaining, temp_assignment_value + 1)
	elif choice == "Assign":
		if is_landing:
			process_landing_assignment(str(temp_assignment_value))
		else:
			process_reinforcement_assignment(str(temp_assignment_value))
		return # Stop here after assigning
		
	# Redraw the UI after a +/- press
	if is_landing:
		ask_for_next_assignment(type)
	else:
		ask_for_next_reinforcement_assignment()
func refit_monitors_for_tanks():
	var troop_monitors = monitors.filter(func(m): return m["carries"] == "troops")
	var refitted = 0
	for i in range(troop_monitors.size() - 1, -1, -1):
		if refitted >= 3: break
		var monitor = troop_monitors[i]
		monitor["name"] = "Tank Lighter " + str(refitted + 1)
		monitor["carries"] = "tanks"
		monitor["soldiers"] = 0
		monitor["tanks_onboard"] = TANKS_PER_LIGHTER
		refitted += 1

func apply_monitor_costs(cost):
	var decommissioned = 0
	for m in monitors:
		if m["carries"] == "troops" and decommissioned < cost:
			m["name"] = "Support Vessel " + str(decommissioned + 1)
			m["carries"] = "support"
			m["soldiers"] = 0
			decommissioned += 1
			


func _get_active_fire_support() -> Array:
	var roster: Array = []
	if typeof(naval_support_ships) == TYPE_ARRAY and not naval_support_ships.is_empty():
		for s in naval_support_ships:
			if typeof(s) == TYPE_DICTIONARY and s.get("status", "Ready") == "Ready":
				roster.append(s)
	else:
		# Fallback if roster is not initialized
		pass
	return roster

func _ship_opening_lines(ships:Array) -> String:
	if ships.is_empty(): return ""
	var line = ""
	var lead = ships[0].get("name", "A battleship")
	line += lead + " opens fire with a deafening roar.\n"
	if ships.size() >= 2:
		line += ships[1].get("name","Another ship") + " joins the broadside.\n"
	return line

func _accuracy_flavour(ships:Array) -> String:
	if ships.is_empty(): return ""
	# (Your existing flavour text logic)
	return "Gunners report their salvos are landing on target.\n"

func _fleet_sub_contact_lines(ships:Array) -> String:
	if ships.is_empty(): return ""
	var active = ships.filter(func(s): return s.get("status", "") == "Ready")
	if active.is_empty(): return ""
	var base = 0.03 * active.size()
	if q_ship_assignment == "fleet": base *= 0.2
	if randf() >= base: return ""
	var text = "\n**U-BOAT CONTACT!**\n"
	var target = active.pick_random()
	target["status"] = "Sunk" if target.get("class") == "steam" else "Disabled"
	text += " > " + target["name"] + " is torpedoed and out of action!\n"
	return text
# --- REPLACE THE OLD FUNCTION WITH THIS ---
func bombard_target(target_name):
	var target = targets[target_name]
	
	var active_ships = _get_active_fire_support()
	if active_ships.is_empty():
		return # No ships, no bombardment

	# 1. Calculate the fleet's base Firepower Score
	var total_firepower = 0
	for ship in active_ships:
		if ship.get("class") == "qe":
			total_firepower += 20 # Dreadnought
		elif ship.get("class") == "tribal":
			total_firepower += 4  # Destroyer

	# 2. Apply multipliers based on conditions
	var spotting_multiplier = 1.0
	if bombardment_plan == "bacon":
		spotting_multiplier = 1.75
	elif bombardment_plan == "balloons":
		spotting_multiplier = 1.35

	var time_multiplier = 1.0
	if time_of_day_effective == "night":
		time_multiplier = 0.5
	elif time_of_day_effective == "morning":
		time_multiplier = 0.8

	# 3. Calculate final effectiveness percentage
	# CHANGE: The divisor is lowered from 275.0 to 150.0 to prevent zero-damage results.
	var final_firepower = total_firepower * spotting_multiplier * time_multiplier
	var base_effectiveness = final_firepower / 150.0

	# 4. Allocate effectiveness based on player's targeting choice
	var artillery_reduction_percent = 0.0
	var garrison_reduction_percent = 0.0
	
	if naval_bombardment_target_focus == "batteries":
		artillery_reduction_percent = base_effectiveness
		garrison_reduction_percent = base_effectiveness * 0.3 # Collateral damage
	elif naval_bombardment_target_focus == "garrison":
		artillery_reduction_percent = base_effectiveness * 0.3
		garrison_reduction_percent = base_effectiveness
	elif naval_bombardment_target_focus == "split":
		artillery_reduction_percent = base_effectiveness * 0.7
		garrison_reduction_percent = base_effectiveness * 0.7
		
	# 5. Add a small amount of randomness to the final result
	artillery_reduction_percent *= randf_range(0.85, 1.15)
	garrison_reduction_percent *= randf_range(0.85, 1.15)

	# Apply final calculated damage (using floori to ensure whole numbers)
	var art_damage = floori(target.artillery * artillery_reduction_percent)
	var gar_damage = floori(target.garrison * garrison_reduction_percent)
	
	target.artillery = max(0, target.artillery - art_damage)
	target.garrison  = max(0, target.garrison  - gar_damage)
func _advance_to_next_consolidation_turn():
	consolidation_turn_current += 1
	rfc_used_this_turn = false
	consolidation_plan.clear()
	current_assignment_index = 0
	ask_for_next_consolidation_order()

func process_redeployment_destination(choice):
	var destination = ""
	var valid_options = []
	for beach in landing_assignment_order:
		if beach != temp_redeployment_source:
			valid_options.append(beach)
	var choice_index = int(choice) - 1
	if choice_index >= 0 and choice_index < valid_options.size():
		destination = valid_options[choice_index]
	else:
		temp_redeployment_source = ""
		ask_for_next_consolidation_order()
		return
	consolidation_plan[temp_redeployment_source] = {"action": "redeploy", "to": destination}
	temp_redeployment_source = ""
	current_assignment_index += 1
	if current_assignment_index < landing_assignment_order.size():
		ask_for_next_consolidation_order()
	else:
		resolve_consolidation_turn()



func on_choice_made(extra_arg_0: String) -> void:
	pass # Replace with function body.

func draw_embarkation_ui():
	# 1. Clear any existing units from the lists
	for child in middelkerke_unit_list.get_children(): child.queue_free()
	for child in westende_unit_list.get_children(): child.queue_free()
	for child in nieuwpoort_unit_list.get_children(): child.queue_free()

	# 2. Prepare data holders for the loop
	var beach_data = {
		"Middelkerke Bains": {"strength": 0, "node": middelkerke_unit_list, "destinations": ["Westende Bains", "Nieuwpoort Bains"]},
		"Westende Bains": {"strength": 0, "node": westende_unit_list, "destinations": ["Middelkerke Bains", "Nieuwpoort Bains"]},
		"Nieuwpoort Bains": {"strength": 0, "node": nieuwpoort_unit_list, "destinations": ["Middelkerke Bains", "Westende Bains"]}
	}

	# 3. Loop through every unit and create its UI element
	for unit in division_order_of_battle:
		var dest = unit.current_dest
		
		# Add strength to the correct beach
		beach_data[dest].strength += unit.strength
		
		# Create the UI row for the unit
		var row = HBoxContainer.new()
		var label = Label.new()
		label.text = unit.name + " [" + str(unit.strength) + "]"
		label.set_h_size_flags(Control.SIZE_EXPAND_FILL)
		row.add_child(label)
		
		# Create the 'Divert' buttons
		var dest1_name = beach_data[dest].destinations[0]
		var dest2_name = beach_data[dest].destinations[1]

		var button1 = Button.new()
		button1.text = "> " + dest1_name.substr(0, 1) # e.g., "> W"
		button1.pressed.connect(_on_divert_unit_button_pressed.bind(unit, dest1_name))
		row.add_child(button1)
		
		var button2 = Button.new()
		button2.text = "> " + dest2_name.substr(0, 1) # e.g., "> N"
		button2.pressed.connect(_on_divert_unit_button_pressed.bind(unit, dest2_name))
		row.add_child(button2)

		# Add the completed row to the correct column in the scene tree
		beach_data[dest].node.add_child(row)

	# 4. After the loop, update all the summary labels
	var total_barges = 0
	print("--- Recalculating Beach Strength ---") # DEBUG

	for beach_name in beach_data:
		var data = beach_data[beach_name]
		var strength = data.strength
		var barges = ceil(strength / float(SOLDIERS_PER_BARGE))
		total_barges += barges
		print(" > ", beach_name, " | Calculated Strength: ", strength, " | Barges: ", barges)
		# Find the correct stats label and update it (you'll need the @onready vars)
		match beach_name:
			"Middelkerke Bains":
				middelkerke_stats.text = "Strength: " + str(strength) + " | Barges: " + str(barges)
			"Westende Bains":
				westende_stats.text = "Strength: " + str(strength) + " | Barges: " + str(barges)
			"Nieuwpoort Bains":
				nieuwpoort_stats.text = "Strength: " + str(strength) + " | Barges: " + str(barges)

	summary_label.text = "Total Barges Committed: " + str(total_barges) + " / " + str(TOTAL_REINFORCEMENT_BARGES)

func _on_divert_unit_button_pressed(unit_data, new_destination):
	# Update the data model
	unit_data.current_dest = new_destination
	
	# Redraw the entire UI to reflect the change
	draw_embarkation_ui()

# --- THEME HELPER FUNCTION ---
func _create_and_apply_theme():
	# 1. Create a new, blank Theme resource in memory.
	var new_theme = Theme.new()
	
	# 2. Define the font and colors we want to use.
	var default_font = load("res://assets/cour.ttf") # IMPORTANT: Make sure this path is correct!
	var font_color = Color("6631df")
	var background_color = Color("f7f0e6")
	
	# 3. Create a StyleBox for the background. This is how Godot handles panel colors.
	var bg_stylebox = StyleBoxFlat.new()
	bg_stylebox.bg_color = background_color
	
	# 4. Set the properties on the theme for the base "Control" type.
	# Any other control (Labels, Buttons, etc.) will inherit these unless overridden.
	new_theme.set_font("font", "Control", default_font)
	new_theme.set_font_size("font_size", "Control", 16)
	new_theme.set_color("font_color", "Control", font_color)
	new_theme.set_stylebox("panel", "Control", bg_stylebox)
	
	# 5. Apply the completed theme to the root UI node.
	# We'll assume your root node is called "UI" and this script is attached to it.
	# If your root UI node is the VBoxContainer, you can set it there instead.
	self.theme = new_theme
